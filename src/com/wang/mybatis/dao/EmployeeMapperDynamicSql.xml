<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.wang.mybatis.dao.EmployeeMapperDynamicSql">
    <!--
• if:判断
• choose (when, otherwise):分支选择；带了break的swtich-case
	如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中一个
• trim 字符串截取(where(封装查询条件), set(封装修改条件))
• foreach 遍历集合
	 -->
    <select id="getEmpsByCondationIf" resultType="Employee">
--       第一种方式
        <!--select * from mybatis_employee where 1=1-->
        <!--&lt;!&ndash; test：判断表达式（OGNL）-->
		 	<!--OGNL参照PPT或者官方文档。-->
		 	  	 <!--c:if  test-->
		 	<!--从参数中取值进行判断-->

		 	<!--遇见特殊符号应该去写转义字符：-->
		 	<!--&&：-->
		 	<!--&ndash;&gt;-->
        <!--<if test="id != null">-->
            <!--and id = #{id}-->
        <!--</if>-->
        <!--<if test="lastName != null and lastName.trim() != '' ">-->
            <!--and last_name like #{lastName}-->
        <!--</if>-->
        <!--<if test="email != null">-->
            <!--and email like #{email}-->
        <!--</if>-->

--         第二种方式
--         或者使用mybatis推荐的where标签来拼多个查询条件
--         而且where会帮我们去掉前面多余的and，但是 如果and放在后面where是不能我们去掉的
        select * from mybatis_employee
        <where>
            <if test="id != null">
                and id = #{id}
            </if>
            <if test="lastName != null and lastName.trim() != '' ">
                and last_name like #{lastName}
            </if>
            <if test="email != null">
                and email like #{email}
            </if>
        </where>

--         第三种方式 这种方式用的不多 作为了解
        <!-- 后面多出的and或者or where标签不能解决
	 	prefix="":前缀：trim标签体中是整个字符串拼串 后的结果。
	 			prefix给拼串后的整个字符串加一个前缀
	 	prefixOverrides="":
	 			前缀覆盖： 去掉整个字符串前面多余的字符
	 	suffix="":后缀
	 			suffix给拼串后的整个字符串加一个后缀
	 	suffixOverrides=""
	 			后缀覆盖：去掉整个字符串后面多余的字符

	 	-->
        <!--select * from mybatis_employee-->
        <!--<trim prefix="where" suffixOverrides="and">-->
            <!--<if test="id != null">-->
                <!--and id = #{id}-->
            <!--</if>-->
            <!--<if test="lastName != null and lastName.trim() != '' ">-->
                <!--and last_name like #{lastName}-->
            <!--</if>-->
            <!--<if test="email != null">-->
                <!--and email like #{email}-->
            <!--</if>-->
        <!--</trim>-->

    </select>

    <select id="getEmpsByCondationChoose" resultType="Employee">
        select * from mybatis_employee
        <where>
            <choose>
                <when test="id != null" >
                    id = #{id}
                </when>
                <when test="lastName != null and lastName.trim() != '' " >
                    last_name like #{lastName}
                </when>
                <when test="email != null and email.trim() != '' ">
                    email like #{email}
                </when>
            </choose>
        </where>
    </select>
    <!--set-->
    <update id="updateEmp" >
        update mybatis_employee
        <set>
            <if test="id != null">
                id = #{id},
            </if>
            <if test="lastName != null and lastName.trim() != '' ">
                last_name = #{lastName},
            </if>
            <if test="email != null">
                email = #{email}
            </if>
        </set>
    </update>

    <!--forEach-->
    <select id="getEmpsByCondationForEach" resultType="Employee">
        select * from mybatis_employee
        <where>
            id in
            <foreach collection="ids" item="item_id" separator="," open="(" close=")">
                #{item_id}
            </foreach>
        </where>
    </select>

    <insert id="addEmps" >
        insert into mybatis_employee(last_name,email,d_id)
        values
        <foreach collection="emps" item="emp" separator="," >
            (#{emp.lastName} ,#{emp.email}, #{emp.department.id})
        </foreach>
    </insert>

    <!-- 这种方式需要数据库连接属性allowMultiQueries=true；
        这种分号分隔多个sql可以用于其他的批量操作（删除，修改） -->
    <!-- <insert id="addEmps">
        <foreach collection="emps" item="emp" separator=";">
            insert into tbl_employee((last_name,email,d_id)
            values(#{emp.lastName} ,#{emp.email}, #{emp.department.id})
        </foreach>
    </insert> -->

    <!-- Oracle数据库批量保存：
	 	Oracle不支持values(),(),()
	 	Oracle支持的批量方式
	 	1、多个insert放在begin - end里面
	 		begin
			    insert into employees(employee_id,last_name,email)
			    values(employees_seq.nextval,'test_001','test_001@atguigu.com');
			    insert into employees(employee_id,last_name,email)
			    values(employees_seq.nextval,'test_002','test_002@atguigu.com');
			end;
		2、利用中间表：
			insert into employees(employee_id,last_name,email)
		       select employees_seq.nextval,lastName,email from(
		              select 'test_a_01' lastName,'test_a_e01' email from dual
		              union
		              select 'test_a_02' lastName,'test_a_e02' email from dual
		              union
		              select 'test_a_03' lastName,'test_a_e03' email from dual
		       )
	 -->

</mapper>